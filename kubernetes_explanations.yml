# fichier pv-volume.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: task-pv-volume
  labels:
    type: local
spec:
#  Nom de la classe de stockage (storageClassName)
  storageClassName: manual
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
# le hostPath est le chemin sur le nœud hôte où les données sont réellement stockées. 
# C'est la ou recuperer les données persistantes
  hostPath:
    path: "/mnt/data"

---
# fichier pvc-claim.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: task-pv-claim
spec:
  storageClassName: manual
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 3Gi

---
# fichier deploy.yaml
apiVersion: apps/v1
# kind : le type d'objet que l'on souhaite créer
kind: Deployment
# metadata : des métadonnées sur l'objet (nom, étiquettes, ...)
metadata:
  name: my-sentiment-analysis-deployment
  labels:
    app: my-sentiment-analysis-api
spec:
  selector:
    matchLabels:
      app: my-sentiment-analysis-api
# spec.replicas : spécifie le nombre de Pods à exécuter pour ce déploiement.
  replicas: 2
# strategy.type : spécifie la stratégie de déploiement à utiliser
  strategy:
    type: RollingUpdate # RollingUpdate : les nouvelles versions suite à maj seront progressivement déployées
    matchLabels:
      app: my-sentiment-analysis-api
  template:
    metadata:
      labels:
        app: my-sentiment-analysis-api
# specs: les spécifications de l'objet (état désiré de l'objet).
    spec:
      volumes:
        - name: my-volume # Nom du volume pour le stockage des données persistantes
          persistentVolumeClaim:
            claimName: task-pv-claim # Nom du PVC à utiliser. 
      containers:
      - name: my-sentiment-analysis-api
        image: fake-api:1.0.0
        ports:
# Préciser le ports exposés dans le conteneurs, ici le port 8000 (cf Dockerfile)
        - containerPort: 8000
# resources : les ressources allouées au conteneur (conseillé mais non obligatoire).
        resources:
          limits:
            cpu: "1"
            memory: "1Gi"
        # le mountPath est le chemin dans le conteneur Docker où le volume est monté, 
        # et qui deversera les données persistantes dans le dossier path: "/mnt/data" (définit dans le PV)
        volumeMounts:
          - mountPath: "/container-data"
            name: my-volume

---
# fichier mariadb-secrets.yaml pour établir notre secret MYSQL_ROOT_PASSWORD
apiVersion: v1
kind: Secret
metadata:
  name: mariadb-rootpass
type: Opaque
data:
  password: c2VjcmV0 # Mot de passe encodé (base64)
---
apiVersion: v1
kind: Secret
metadata:
  name: mariadb-user
type: Opaque
data:
  username: c3ViamVjdA== # Nom d'utilisateur encodé (base64)
  password: c2VjcmV0 # Mot de passe encodé (base64)

---
# fichier mariadb-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mariadb-datascientest-config
data:
  max_allowed_packet.cnf: |
    [mysqld]
    max_allowed_packet = 128M

---
# fichier statefulset.yml (stockage persistant pour survivre aux redémarrages de service.)
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mariadb-deployment
  labels:
    app: mariadb
spec:
  serviceName: maria
  replicas: 2
  selector:
    matchLabels:
      app: mariadb
  template:
    metadata:
      labels:
        app: mariadb
    spec:
      containers:
        - image: docker.io/mariadb:10.4
          name: mariadb
          env:
# Le nom du secret est le nom de la variable d'environnement ajoutée au conteneur
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mariadb-rootpass
                  key: password
# envFrom est une liste de sources permettant à Kubernetes de prendre des variables d'environnement
          envFrom:
            - secretRef:
                name: mariadb-user
          ports:
            - containerPort: 3306
              protocol: TCP
          resources:
            limits:
              cpu: "1"
              memory: "1Gi"
          volumeMounts:
# /var/lib/mysql à l’intérieur du conteneur sera monté avec le volume mariadb-volume-1
            - mountPath: /var/lib/mysql
              name: mariadb-volume-1
# /etc/mysql/conf.d à l’intérieur du conteneur sera monté avec le volume nommé mariadb-datascientest-config-volume
            - mountPath: /etc/mysql/conf.d
              name: mariadb-config-volume
      volumes:
# mariadb-volume-1 est un volume vide (emptyDir). 
# Les données stockées dans ce volume ne sont pas persistantes et seront perdues lorsque le pod est supprimé ou redémarré.
        - emptyDir: {}
          name: mariadb-volume-1
# ConfigMap indique à Kubernetes d'utiliser mariadb-datascientest-config, 
# En prenant le contenu de la clé max_allowed_packet.cnf et le contenu de max_allowed_packed.cnf
        - configMap:
            name: mariadb-datascientest-config
            items:
              - key: max_allowed_packet.cnf
                path: max_allowed_packet.cnf
          name: mariadb-config-volume

---
# Fichier clusterip.yml
apiVersion: v1
# kind: Service : spécifie le type d'objet que nous créons à savoir un service.
kind: Service
# spec:type : spécifie le type de service à créer (ClusterIP étant par défaut).
spec:
# Le sélecteur identifie les Pods qui doivent être inclus dans le service. 
# Dans cet exemple, les Pods portant l'étiquette app: nginx-deployment seront sélectionnés par ce service.
  selector:
    app: nginx-deployment
  ports:
    - name: http
      protocol: TCP
# spec:port : spécifie le port sur lequel le service sera exposé.
      port: 80
# spec:targetPort : spécifie le port sur lequel le service enverra le trafic.
      targetPort: 8000

---
# Fichier nodeport.yml
apiVersion: v1
# kind: Service : spécifie le type d'objet que nous créons à savoir un service.
kind: Service
# metadata:name : c'est le nom logique du service, qui deviendra également le nom DNS du service lors de sa création.
metadata:
  name: monservicenodeport
# spec:type : spécifie le type de service à créer. Dans cet exemple, nous créons un service NodePort.
spec:
  type: NodePort
# Le sélecteur identifie les Pods qui doivent être inclus dans le service. 
# Dans cet exemple, les Pods portant l'étiquette app: nginx-deployment seront sélectionnés par ce service.
  selector:
    app: nginx-deployment
  ports:
    - name: http
      protocol: TCP
# spec:port : spécifie le port sur lequel le service sera exposé.
      port: 80
# spec:targetPort : spécifie le port sur lequel le service enverra le trafic.
      targetPort: 8000
# spec:nodePort : spécifie le port du nœud sur lequel le service sera exposé via Nodeport.
      nodePort: 30000

---
# Fichier loadbalancer.yml
apiVersion: v1
# kind: Service : spécifie le type d'objet que nous créons à savoir un service.
kind: Service
# metadata:name : c'est le nom logique du service, qui deviendra également le nom DNS du service lors de sa création.
metadata:
  name: monserviceloadbalancer
# spec:type : spécifie le type de service à créer.
spec:
  type: LoadBalancer
# spec:clusterIP : spécifie l'adresse IP utilisé pour la communication interne du cluster entre les pods.
  clusterIP: 10.43.5.11
# spec:loadBalancerIP : spécifie l'adresse IP à utiliser pour accéder au service depuis l'extérieur du cluster.
  loadBalancerIP: 168.196.90.10
# Le sélecteur identifie les Pods qui doivent être inclus dans le service. 
# Dans cet exemple, les Pods portant l'étiquette app: nginx-deployment seront sélectionnés par ce service.
  selector:
    app:  nginx-deployment
  ports:
    - name: http
      protocol: TCP
# spec:port : spécifie le port sur lequel le service sera exposé.
      port: 80
# spec:targetPort : spécifie le port sur lequel le service enverra le trafic.
      targetPort: 8000

---
# fichier my-ingress.yml
apiVersion: v1
# kind: Service : spécifie le type d'objet que nous créons à savoir un Ingress.
kind: Ingress
# metadata:name : c'est le nom logique du service, 
metadata:
  name: my-ingress
spec:
  defaultBackend:
# Indique le nom du service (monserviceloadbalancer) auquel l’Ingress est associé.
    service:
      name: monserviceloadbalancer
# port : spécifie le port sur lequel le service sera exposé.
      port:
        number: 80

---

